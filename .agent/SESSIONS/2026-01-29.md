# Sessions: 2026-01-29

**Summary:** Debug mode improvements, schema fixes, UI polish

---

## Session 1: Fix MotionControlJobData Type Errors

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Fixed TypeScript errors in video.processor.ts for MotionControlJobData
- [x] Added `inputImage` and `inputPrompt` fields to MotionControlJobData interface
- [x] Removed unnecessary type casts in video processor

### Files changed

- `apps/api/src/interfaces/job-data.interface.ts` - Added `inputImage?: string` and `inputPrompt?: string` to MotionControlJobData interface to match VideoJobData pattern
- `apps/api/src/processors/video.processor.ts` - Removed `as string | undefined` casts since `image` field is required and fallback always returns string

### Decisions

- **Decision:** Add optional input fields to MotionControlJobData matching VideoJobData pattern
  - **Context:** Processor was using `inputPrompt` and `inputImage` fields that didn't exist on the type
  - **Rationale:** These fields come from node connections (vs legacy direct fields), consistent with other job data types

### Technical Details

The errors were:
1. `inputPrompt` property missing on MotionControlJobData
2. `inputImage` property missing on MotionControlJobData
3. `image` being `undefined` when passed to `generateMotionControlVideo`

Fix: Added the missing optional fields and removed unnecessary casts that were hiding the real types.

### Next steps

- [ ] Continue with other development tasks

---

## Session 2: Negative Prompt Checkbox Selector

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Created NegativePromptSelector component with checkbox-based UI
- [x] Integrated into SchemaInputs.tsx for `negative_prompt` schema fields
- [x] Added 8 predefined negative prompt options (Blurry, Distorted, Low Quality, etc.)
- [x] Added custom text input for additional terms

### Files created

- `apps/web/src/components/nodes/NegativePromptSelector.tsx` - New checkbox selector component for negative prompts

### Files changed

- `apps/web/src/components/nodes/SchemaInputs.tsx` - Added import and rendering logic for NegativePromptSelector when `key === 'negative_prompt'`

### Technical Details

**NegativePromptSelector features:**
- 8 predefined options in 2-column grid: Blurry, Distorted, Low Quality, Watermark, Text/Logos, Artifacts, Grainy/Noisy, Oversaturated
- Bidirectional parsing: parses existing comma-separated values to pre-check matching boxes
- Custom text input for additional terms not in predefined list
- Combines checked items + custom text into comma-separated output
- Memoized with `memo()` for performance

**Integration point in SchemaInputs.tsx:**
- Checks for `key === 'negative_prompt' && property.type === 'string'`
- Renders NegativePromptSelector instead of skipping string types
- Positioned before enum/slider/boolean logic in render loop

### Decisions

- **Decision:** Use 8 most common negative prompt terms
  - **Rationale:** These cover the majority of image/video quality issues users want to avoid
  - **Source:** Based on template defaults like `'blurry, distorted, low quality, watermark'`

### Next steps

- [ ] Test with SDXL or other models that have `negative_prompt` in schema
- [ ] Verify negative_prompt value is passed correctly to API

---

## Session 3: Fix EdgeStyle to Use React Flow's Actual Types

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Changed `EdgeStyle` type from `'bezier'` to `'default'` (React Flow's actual type for bezier curves)
- [x] Updated all default values and settings to use `'default'`
- [x] Added migration logic to convert legacy `'bezier'` values to `'default'`
- [x] Removed mapping functions that were converting between styles
- [x] Updated template seed data to use correct edge style

### System Flow

```
┌──────────────────────────────────────────────────────────────┐
│  EdgeStyle Migration Flow                                     │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  localStorage/Database                                        │
│         │                                                     │
│         ▼                                                     │
│  ┌─────────────────┐    ┌─────────────────┐                  │
│  │ edgeStyle:      │───▶│ Migration:      │                  │
│  │ 'bezier'        │    │ 'bezier'→       │                  │
│  │ (legacy)        │    │ 'default'       │                  │
│  └─────────────────┘    └────────┬────────┘                  │
│                                  │                            │
│                                  ▼                            │
│                         ┌─────────────────┐                  │
│                         │ React Flow:     │                  │
│                         │ type='default'  │                  │
│                         │ (bezier curves) │                  │
│                         └─────────────────┘                  │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

### Files changed

**Type Definition:**
- `packages/types/src/workflow.ts` - Changed EdgeStyle type: `'bezier'` → `'default'`

**Settings Store:**
- `apps/web/src/store/settingsStore.ts` - Updated type, default value, and added migration

**Settings UI:**
- `apps/web/src/components/settings/SettingsModal.tsx` - Updated EDGE_STYLES values

**Workflow Canvas:**
- `apps/web/src/components/canvas/WorkflowCanvas.tsx` - Removed `reactFlowEdgeType` mapping, uses `edgeStyle` directly

**Workflow Store:**
- `apps/web/src/store/workflow/workflowStore.ts` - Updated initial state
- `apps/web/src/store/workflow/slices/edgeSlice.ts` - Removed `toReactFlowEdgeType()`, uses style directly
- `apps/web/src/store/workflow/slices/persistenceSlice.ts` - Simplified to inline migration

**API/Backend:**
- `apps/api/src/schemas/user-settings.schema.ts` - Updated default value
- `apps/api/src/templates/templates.seed.ts` - Updated all templates

**UI Components:**
- `apps/web/src/components/templates/TemplatesModal.tsx` - Added migration for legacy values
- `apps/web/src/components/workflow/GenerateWorkflowModal.tsx` - Updated to use `'default'`

### Decisions

- **Decision:** Use `'default'` instead of `'bezier'` throughout the codebase
  - **Rationale:** React Flow uses `'default'` as the edge type name for bezier curves, not `'bezier'`. Using the correct type eliminates console warnings and makes the code match React Flow's expectations.

- **Decision:** Keep migration logic in place
  - **Rationale:** Existing users may have `'bezier'` stored in localStorage or database. Migration ensures backward compatibility.

### Technical Details

**Problem:** React Flow expects `'default'` for bezier curves but codebase used `'bezier'`, causing console warnings about unknown edge types.

**Solution:**
1. Changed the canonical type to `'default'`
2. Removed all conversion/mapping functions
3. Added migration in `loadFromStorage()`, `normalizeEdgeTypes()`, and `TemplatesModal` to handle legacy data

### Next steps

- [ ] Update test files to use `'default'` for consistency (currently using legacy `'bezier'`)
- [ ] Update documentation (SKILL.md, README files)

---

## Session 4: Pass debugMode Through Workflow Execution

**Duration:** ~20 minutes
**Status:** Complete

### What was done

- [x] Added `debugMode` to base job data interface (inherited by all job types)
- [x] Added `debugMode` field to Execution schema in MongoDB
- [x] Updated ExecutionsService to accept and store debugMode
- [x] Updated ExecutionsController to accept debugMode from request body
- [x] Updated QueueManagerService.enqueueWorkflow() to pass debugMode
- [x] Updated QueueManagerService.enqueueNode() to pass debugMode
- [x] Updated QueueManagerService.continueExecution() to read debugMode from execution record
- [x] Updated WorkflowProcessor to pass debugMode when enqueueing nodes
- [x] Updated ImageProcessor to pass debugMode to ReplicateService and handle mock response
- [x] Updated VideoProcessor with same debug mode handling
- [x] Updated frontend executionSlice to send debugMode in POST body
- [x] Updated SSE subscription to extract and display debug payloads from job results

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Debug Mode Workflow Execution Flow                                     │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Frontend                                                               │
│  ┌─────────────────────────────────┐                                   │
│  │ Settings Store: debugMode=true  │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ POST /workflows/:id/execute     │                                   │
│  │ body: { debugMode: true }       │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│  Backend          │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ ExecutionsController            │                                   │
│  │ → createExecution(workflowId,   │                                   │
│  │    { debugMode })               │                                   │
│  │ → enqueueWorkflow(executionId,  │                                   │
│  │    workflowId, { debugMode })   │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ WorkflowJobData                 │                                   │
│  │ { debugMode: true, ... }        │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ WorkflowProcessor               │                                   │
│  │ → enqueueNode(..., { debugMode })│                                  │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ NodeJobData                     │                                   │
│  │ { debugMode: true, ... }        │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ ImageProcessor/VideoProcessor   │                                   │
│  │ → generateImage({ debugMode })  │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐     ┌──────────────────────────┐ │
│  │ ReplicateService                │────▶│ Returns mock response:   │ │
│  │ if (debugMode) return mock      │     │ { id, status, output,    │ │
│  │ else call Replicate API         │     │   debugPayload: {...} }  │ │
│  └─────────────────────────────────┘     └────────────┬─────────────┘ │
│                                                       │                │
│                   ┌───────────────────────────────────┘                │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ Job result saved with           │                                   │
│  │ debugPayload in MongoDB         │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ SSE Stream includes             │                                   │
│  │ job.result.debugPayload         │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│  Frontend         │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ SSE Subscription extracts       │                                   │
│  │ debugPayloads, adds to store    │                                   │
│  │ → Opens Debug Panel             │                                   │
│  └─────────────────────────────────┘                                   │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Affected Components

**Backend:**
- `apps/api/src/interfaces/job-data.interface.ts`
- `apps/api/src/schemas/execution.schema.ts`
- `apps/api/src/services/executions.service.ts`
- `apps/api/src/services/queue-manager.service.ts`
- `apps/api/src/controllers/executions.controller.ts`
- `apps/api/src/processors/workflow.processor.ts`
- `apps/api/src/processors/image.processor.ts`
- `apps/api/src/processors/video.processor.ts`

**Frontend:**
- `apps/web/src/store/execution/slices/executionSlice.ts`
- `apps/web/src/store/execution/types.ts`
- `apps/web/src/store/execution/helpers/sseSubscription.ts`

### Key Decisions

- **Decision:** Store `debugMode` on the Execution record in MongoDB
  - **Rationale:** `continueExecution()` is called by processors after node completion. It needs to read debugMode to pass to subsequent nodes. Storing on execution record makes it accessible without passing through every function signature.

- **Decision:** Handle debug mode in processors, not in service
  - **Rationale:** Processors already handle the job lifecycle (status updates, logging, continuing execution). Handling debug mode there keeps the service focused on API interactions.

- **Decision:** Skip polling for debug predictions
  - **Rationale:** Mock predictions have no real Replicate ID to poll. Immediately completing with mock data is the correct behavior.

### Technical Details

**Problem:** Debug mode worked when clicking "Retry" on a node (direct API call to `/replicate/image`) but NOT when clicking "Run" in toolbar (workflow execution through queue).

**Root cause:**
- Retry path: Frontend → POST /replicate/image { debugMode } → Service
- Workflow path: Frontend → Controller → Queue → Processor → Service (debugMode never passed)

**Solution:** Thread debugMode through entire chain:
1. Frontend sends `{ debugMode }` in POST body
2. Controller stores in execution record AND passes to queue
3. Queue includes in WorkflowJobData
4. WorkflowProcessor passes to enqueueNode()
5. NodeJobData includes debugMode
6. Processors read from job.data and pass to service
7. Service returns mock response with debugPayload
8. Processor saves debugPayload to job result
9. SSE includes debugPayload in response
10. Frontend extracts and displays in Debug Panel

### Next steps

- [ ] Test end-to-end with Settings → Developer → Debug Mode enabled
- [ ] Verify debug panel shows captured payloads for all nodes
- [ ] Verify no actual Replicate API calls are made in debug mode

---

## Session 5: Debug Mode Bug Fixes and Schema Mapper Improvements

**Duration:** ~30 minutes
**Status:** Complete

### What was done

- [x] Fixed handle ID mapping: `images` → `inputImages` in execution slice
- [x] Fixed array normalization: Single images wrapped in arrays
- [x] Updated schema mapper to only send fields that exist in model's schema
- [x] Added enum validation to schema mapper (rejects invalid values like `webp` when only `jpg`/`png` allowed)
- [x] Improved base64 URL conversion with better logging and error handling
- [x] Fixed DebugPanel event propagation issues

### Files changed

**Frontend:**
- `apps/web/src/store/execution/slices/executionSlice.ts` - Added handleToFieldMap for mapping handle IDs to DTO fields, arrayFields normalization
- `apps/web/src/components/panels/DebugPanel.tsx` - Added `stopPropagation` to prevent click events from deselecting nodes

**Backend:**
- `apps/api/src/services/schema-mapper.service.ts` - Only send schema fields, added `isValidForSchema()` for enum validation
- `apps/api/src/services/files.service.ts` - Better URL parsing regex, more logging
- `apps/api/src/services/replicate.service.ts` - Added debug logging for image conversion

### Technical Details

**Handle ID Mapping:**
```typescript
const handleToFieldMap = {
  images: 'inputImages',  // Node handle ID → DTO field name
  image: 'image',
  video: 'video',
  prompt: 'prompt',
  audio: 'audio',
};
```

**Array Normalization:**
```typescript
const arrayFields = new Set(['inputImages', 'images']);
// Single values wrapped: 'url' → ['url']
```

**Schema Validation:**
- Before: Sent `resolution`, `output_format` even if model doesn't support them
- After: Only sends fields that exist in model's inputSchema
- Added enum check: If schema has `enum: ["jpg", "png"]`, rejects `webp`

### Mistakes and Fixes

1. **Missing images** - Fixed by mapping `images` handle → `inputImages` DTO field
2. **Single image as string** - Fixed by ensuring array fields always contain arrays
3. **422 Unprocessable Entity** - Fixed schema mapper to skip invalid enum values (e.g., `webp`)
4. **Extra fields** - Fixed schema mapper to only include fields that exist in model's schema

### Next steps

- [x] Debug mode feature complete and working

---

## Session 6: Fix Settings Modal Edge Style Preview

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Fixed edge style preview in Settings → Appearance tab
- [x] Nodes were positioned too far apart from the connecting edge
- [x] SVG path now properly connects Node A to Node B

### Files changed

- `apps/web/src/components/settings/SettingsModal.tsx` - Fixed preview layout:
  - Changed container from `max-w-[300px]` to fixed `w-[232px]` (64px + 104px + 64px)
  - Repositioned nodes: Node A at `left-0 bottom-2`, Node B at `right-0 top-2`
  - Updated SVG width from 136px to 104px to fill exact gap between nodes
  - Adjusted path coordinates to properly connect from Node A's right edge to Node B's left edge

### Technical Details

**Problem:** The preview showed Node A and Node B far apart from the curved edge line. The edge appeared to float in the middle without visually connecting to either node.

**Root cause:**
- Original: nodes at `left-8`/`right-8` (32px from edges) in a flexible-width container
- SVG was 100px wide, centered, but didn't reach the nodes

**Solution:**
- Fixed container width: 232px total (64px node + 104px edge + 64px node)
- Nodes positioned at edges: `left-0` and `right-0`
- SVG width matches exact gap: 104px starting at `left-16` (after Node A)
- Path coordinates: start at (0, 56) aligned with Node A center, end at (104, 24) aligned with Node B center

### Next steps

- [x] Continue with other development tasks

---

## Session 7: Fix React Flow Edge Handle Error

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Fixed React Flow error: "Couldn't create edge for target handle id: media"
- [x] Updated 12 template files to use correct handle IDs
- [x] Changed `targetHandle: 'media'` to `targetHandle: 'video'` for video connections
- [x] Changed `targetHandle: 'media'` to `targetHandle: 'image'` for image connections

### Root Cause

Templates were using `targetHandle: 'media'` when connecting to the Output node, but the Output node only has `image` and `video` input handles (defined in `packages/types/src/nodes.ts:1382-1385`), not a `media` handle.

### Files changed

**Video connections** (changed to `targetHandle: 'video'`):
- `apps/web/src/templates/image-to-video.ts`
- `apps/web/src/templates/full-pipeline.ts`
- `apps/web/src/templates/generated/facecam-avatar.ts`
- `apps/web/src/templates/generated/dance-video.ts`
- `apps/web/src/templates/generated/extended-video.ts`
- `apps/web/src/templates/generated/grid-to-video.ts`
- `apps/web/src/templates/generated/youtube-video-generator.ts`
- `apps/web/src/templates/generated/stream-to-social.ts`
- `apps/web/src/templates/generated/voice-to-video.ts`

**Image connections** (changed to `targetHandle: 'image'`):
- `apps/web/src/templates/image-series.ts`
- `apps/web/src/templates/generated/instagram-carousel.ts` (3 edges)
- `apps/web/src/templates/generated/social-brand-kit.ts` (4 edges)
- `apps/web/src/templates/generated/youtube-thumbnail-script.ts`

### Decisions

- **Decision:** Update templates to use correct handle IDs instead of adding a 'media' handle to Output node
  - **Rationale:** More explicit, matches actual node definition, avoids type detection complexity

### Known Issue

- `youtube-thumbnail-script.ts:241` has an edge connecting `sourceHandle: 'text'` to the output node, but Output node doesn't accept text inputs. This is a separate issue.

### Next steps

- [ ] Fix youtube-thumbnail-script.ts text-to-output edge (output node doesn't accept text)

---

## Session 8: Fix DebugPanel Double-Click and Clipboard Issues

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Diagnosed double-click issue in DebugPanel (clicks bubbling to React Flow canvas)
- [x] Diagnosed clipboard copy not working (event propagation interference)
- [x] Created reusable `PanelContainer` component for event isolation
- [x] Refactored DebugPanel to use PanelContainer (cleaner than individual stopPropagation calls)

### System Flow

```
┌────────────────────────────────────────────────────────────────┐
│  Event Propagation Problem & Solution                           │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  BEFORE (Problem):                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────────┐ │
│  │ Button Click │───▶│ DebugPanel   │───▶│ React Flow       │ │
│  │ in Panel     │    │ (no stop)    │    │ Canvas handlers  │ │
│  └──────────────┘    └──────────────┘    └──────────────────┘ │
│                                            ↓                    │
│                                     Node deselection,           │
│                                     focus stealing,             │
│                                     requires 2nd click          │
│                                                                 │
│  AFTER (Solution):                                              │
│  ┌──────────────┐    ┌──────────────┐                          │
│  │ Button Click │───▶│ PanelContainer│    [Events stopped]     │
│  │ in Panel     │    │ stopPropagation│                        │
│  └──────────────┘    └──────────────┘                          │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

### Files created

- `apps/web/src/components/panels/PanelContainer.tsx` - Reusable wrapper that stops click/mouseDown/pointerDown/doubleClick propagation

### Files changed

- `apps/web/src/components/panels/DebugPanel.tsx` - Wrapped in PanelContainer, removed individual stopPropagation calls
- `apps/web/src/components/panels/index.ts` - Added PanelContainer export

### Technical Details

**Problem:**
1. Copy icon didn't work - clipboard API failed due to event interference
2. All buttons required double-click - first click was captured by React Flow's pane handlers

**Root cause:** Panels rendered as siblings to WorkflowCanvas still had events bubble up through the ReactFlowProvider context.

**Solution:** Created `PanelContainer` component that stops propagation at the container level:
```typescript
export const PanelContainer = forwardRef<HTMLDivElement, PanelContainerProps>(
  ({ children, className, ...props }, ref) => {
    const stopPropagation = (e: React.SyntheticEvent) => {
      e.stopPropagation();
    };
    return (
      <div
        onClick={stopPropagation}
        onMouseDown={stopPropagation}
        onPointerDown={stopPropagation}
        onDoubleClick={stopPropagation}
        {...props}
      >
        {children}
      </div>
    );
  }
);
```

**Why this is better than per-button stopPropagation:**
- Single point of event isolation
- No need to remember stopPropagation on every handler
- Reusable for other panels (AIGeneratorPanel, etc.)
- Cleaner component code

### Decisions

- **Decision:** Create reusable PanelContainer instead of adding stopPropagation to every button
  - **Rationale:** DRY principle - panels share the same event isolation need. One wrapper handles all.

- **Decision:** Stop multiple event types (click, mouseDown, pointerDown, doubleClick)
  - **Rationale:** React Flow uses different event types for different interactions. Comprehensive blocking prevents all interference.

### References

- [React Flow Utility Classes](https://reactflow.dev/learn/customization/utility-classes)
- [React Flow Panel Component](https://reactflow.dev/api-reference/components/panel)

### Next steps

- [ ] Apply PanelContainer to AIGeneratorPanel if it has similar issues
- [ ] Apply PanelContainer to NodePalette if needed

---

## Session 9: Collapse Negative Prompt Selector

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Made NegativePromptSelector collapsible by default
- [x] Added expand/collapse toggle with chevron icon
- [x] Added "X selected" count indicator when collapsed

### Files changed

- `apps/web/src/components/nodes/NegativePromptSelector.tsx`
  - Added `isExpanded` state (default: `false`)
  - Added clickable header row with chevron icons (ChevronDown/ChevronRight from lucide-react)
  - Added `selectedCount` calculation showing number of checked items + custom text
  - Wrapped checkbox grid and custom input in conditional render based on `isExpanded`

### Technical Details

**Before:** Negative prompt options always visible, taking up significant node space

**After:**
- Collapsed by default - shows only "Negative Prompt" label with "X selected" count
- Click header to expand/collapse
- ChevronRight when collapsed, ChevronDown when expanded
- Selection count includes both predefined checkboxes and custom text (if non-empty)

### Decisions

- **Decision:** Collapse by default
  - **Rationale:** Negative prompt is a secondary option most users don't need to modify frequently. Collapsed state reduces visual clutter on nodes.

### Next steps

- [x] Feature complete

---

## Session 10: Fix Debug Payload Not Showing in SSE Stream

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Fixed debug payloads not appearing in Debug Panel when running workflows from topbar
- [x] Added `result` field to Job schema for storing debug payload
- [x] Created `createDebugJob()` method in ExecutionsService
- [x] Updated ReplicateService to create Job records in debug mode

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Debug Payload Storage - Before vs After                                │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE (Bug):                                                          │
│  ┌──────────────────┐    ┌──────────────────┐                          │
│  │ ReplicateService │    │ QueueJob (queue_ │    Job (jobs)            │
│  │ generateImage()  │───▶│ jobs collection) │    collection:           │
│  │ debugMode=true   │    │ result: {        │    [NO RECORD            │
│  │                  │    │   debugPayload   │     CREATED]             │
│  │ Returns early,   │    │ }                │                          │
│  │ no createJob()   │    └──────────────────┘                          │
│  └──────────────────┘                                                   │
│                              ↓                                          │
│                       SSE queries Job collection                        │
│                       → No debugPayload found!                          │
│                                                                         │
│  AFTER (Fixed):                                                         │
│  ┌──────────────────┐    ┌──────────────────┐    ┌──────────────────┐ │
│  │ ReplicateService │    │ QueueJob (queue_ │    │ Job (jobs)       │ │
│  │ generateImage()  │───▶│ jobs collection) │    │ collection:      │ │
│  │ debugMode=true   │    │ ...              │    │ result: {        │ │
│  │                  │    └──────────────────┘    │   debugPayload   │ │
│  │ createDebugJob() │─────────────────────────▶│ }                │ │
│  └──────────────────┘                            └──────────────────┘ │
│                                                          ↓              │
│                                                   SSE queries Job       │
│                                                   → debugPayload found! │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Root Cause

There are two separate job collections:
1. **`QueueJob`** (`queue_jobs` collection) - Used by BullMQ queue system
2. **`Job`** (`jobs` collection) - Used by SSE stream endpoint

In debug mode, `ReplicateService.generateImage/Video()` returned early with mock data but never created a `Job` record. The SSE stream queries the `jobs` collection via `findJobsByExecution()`, so it never found any debug payloads.

### Files changed

**Backend:**
- `apps/api/src/schemas/job.schema.ts` - Added `result?: Record<string, unknown>` field to store debug payload
- `apps/api/src/services/executions.service.ts` - Added `createDebugJob()` method that creates a Job record with mock predictionId, output, and debugPayload in result field
- `apps/api/src/services/replicate.service.ts` - Updated `generateImage()` and `generateVideo()` debug mode paths to call `createDebugJob()` before returning

### Technical Details

**New method in ExecutionsService:**
```typescript
async createDebugJob(
  executionId: string,
  nodeId: string,
  mockPredictionId: string,
  output: Record<string, unknown>,
  debugPayload: { model: string; input: Record<string, unknown>; timestamp: string }
): Promise<Job> {
  const job = new this.jobModel({
    executionId: new Types.ObjectId(executionId),
    nodeId,
    predictionId: mockPredictionId,
    status: 'succeeded',
    output,
    result: { debugPayload },
  });
  return job.save();
}
```

**Updated debug mode in ReplicateService:**
```typescript
if (input.debugMode) {
  const mockId = `debug-img-${Date.now()}`;
  // ... mock data setup ...

  // Create debug job record so SSE stream can return it
  await this.executionsService.createDebugJob(
    executionId,
    nodeId,
    mockId,
    { image: mockOutput },
    debugPayload
  );

  return { id: mockId, status: 'succeeded', output: mockOutput, debugPayload };
}
```

### Decisions

- **Decision:** Add `result` field to Job schema rather than modifying SSE to query QueueJob
  - **Rationale:** Keeps SSE stream simple, Job schema is the right place for API response data

- **Decision:** Create Job record with mock predictionId in debug mode
  - **Rationale:** Job schema requires unique predictionId. Using `debug-img-{timestamp}` ensures uniqueness while being clearly identifiable as debug data

### Next steps

- [x] Debug mode feature complete

---

## Session 11: Fix Debug Panel Copy Button and Clean Legacy URL Code

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Fixed DebugPanel copy button not working (added `stopPropagation` + `execCommand` fallback)
- [x] Removed legacy URL format handling from codebase (no `@deprecated` backward compat)
- [x] Cleaned up `urlToBase64` to only handle current URL format

### Files changed

**Frontend:**
- `apps/web/src/components/panels/DebugPanel.tsx`
  - Added `e.stopPropagation()` to `handleCopy` to prevent event bubbling
  - Added `execCommand('copy')` fallback when clipboard API fails

**Backend:**
- `apps/api/src/services/files.service.ts`
  - Simplified `urlToBase64` to only handle `/api/files/workflows/{id}/input/{filename}` format
  - Removed legacy `/api/files/input/{id}/{filename}` pattern handling

### Technical Details

**Copy button fix:**
```typescript
const handleCopy = useCallback(
  async (e: React.MouseEvent) => {
    e.stopPropagation();
    try {
      await navigator.clipboard.writeText(JSON.stringify(payload.input, null, 2));
      // ... success handling
    } catch {
      // Fallback to execCommand for older browsers/restricted contexts
      const textArea = document.createElement('textarea');
      textArea.value = JSON.stringify(payload.input, null, 2);
      // ... fallback implementation
    }
  },
  [payload.input]
);
```

**Root cause of old URLs:** User had workflow documents in MongoDB with old URL format from before route migration. Solution: re-upload images to get new URLs.

### Decisions

- **Decision:** Remove legacy URL handling instead of maintaining backward compatibility
  - **Rationale:** User prefers clean code over deprecated cruft. Old URLs in database can be fixed by re-uploading files.

### Next steps

- [ ] Re-upload images in workflows that have old URL format

---

## Session 12: Fix Kling Aspect Ratio and Duration Schema Mismatch

**Duration:** ~20 minutes
**Status:** Complete

### What was done

- [x] Fixed aspect ratio dropdown showing invalid options (e.g., "3:4") for Kling model
- [x] Fixed duration being sent as string instead of integer
- [x] Updated sync script to extract componentSchemas (actual enum definitions) from Replicate API
- [x] Added componentSchemas field to ProviderModel and SelectedModel types
- [x] Updated models API route to pass componentSchemas to frontend
- [x] Updated VideoGenNode and ImageGenNode to store and pass componentSchemas
- [x] Updated SchemaInputs to use model-specific enums and coerce types (string → integer)

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Model Schema Enum Resolution Flow                                       │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE (Bug):                                                          │
│  ┌──────────────────────────────┐                                       │
│  │ SchemaInputs                 │                                       │
│  │ DEFAULT_ENUM_VALUES = {      │    Kling API expects:                 │
│  │   aspect_ratio: ['1:1',      │    aspect_ratio: ["16:9","9:16","1:1"]│
│  │     '16:9','3:4','4:3',...], │    duration: 5 | 10 (integer)         │
│  │   duration: ['4','5','6'...] │                                       │
│  │ }                            │    Mismatch → 422 Error               │
│  └──────────────────────────────┘                                       │
│                                                                         │
│  AFTER (Fixed):                                                         │
│  ┌──────────────────────────────┐    ┌──────────────────────────────┐  │
│  │ Replicate API                │    │ schemas.json                 │  │
│  │ openapi.components.schemas:  │───▶│ componentSchemas: {          │  │
│  │   aspect_ratio: {            │    │   aspect_ratio: {            │  │
│  │     enum: ["16:9","9:16",    │    │     enum: ["16:9","9:16",    │  │
│  │            "1:1"],           │    │            "1:1"],           │  │
│  │     type: "string"           │    │     type: "string"           │  │
│  │   },                         │    │   },                         │  │
│  │   duration: {                │    │   duration: {                │  │
│  │     enum: [5, 10],           │    │     enum: [5, 10],           │  │
│  │     type: "integer"          │    │     type: "integer"          │  │
│  │   }                          │    │   }                          │  │
│  └──────────────────────────────┘    └────────────┬─────────────────┘  │
│                                                    │                    │
│                                                    ▼                    │
│  ┌──────────────────────────────┐    ┌──────────────────────────────┐  │
│  │ models/route.ts              │    │ VideoGenNode                 │  │
│  │ return {                     │───▶│ selectedModel: {             │  │
│  │   ...model,                  │    │   componentSchemas: {...}    │  │
│  │   componentSchemas: {...}    │    │ }                            │  │
│  │ }                            │    └────────────┬─────────────────┘  │
│  └──────────────────────────────┘                 │                    │
│                                                    ▼                    │
│                                     ┌──────────────────────────────┐   │
│                                     │ SchemaInputs                 │   │
│                                     │ enumValues = model-specific  │   │
│                                     │ componentSchemas = type info │   │
│                                     │                              │   │
│                                     │ if (type === 'integer')      │   │
│                                     │   onChange(parseInt(v))      │   │
│                                     └──────────────────────────────┘   │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Root Cause

1. `SchemaInputs.tsx` used hardcoded `DEFAULT_ENUM_VALUES` that didn't match model-specific enums
2. Kling only accepts `"16:9"`, `"9:16"`, `"1:1"` for aspect_ratio (not `"3:4"`, `"4:3"`, etc.)
3. Kling's `duration` is an integer (5 or 10), but dropdowns passed strings
4. The sync script saved `inputSchema` but not the `componentSchemas` that contain actual enum definitions

### Files changed

**Sync Script:**
- `scripts/sync-replicate-schemas.ts` - Added extraction of componentSchemas from `openapi.components.schemas`

**Types:**
- `packages/types/src/nodes.ts` - Added `componentSchemas?: Record<string, unknown>` to `ProviderModel` and `SelectedModel` interfaces

**API Route:**
- `apps/web/src/app/api/providers/models/route.ts` - Include componentSchemas in model response

**Frontend Components:**
- `apps/web/src/components/nodes/ai/VideoGenNode.tsx` - Store and pass componentSchemas to SchemaInputs
- `apps/web/src/components/nodes/ai/ImageGenNode.tsx` - Same changes
- `apps/web/src/components/nodes/SchemaInputs.tsx` - Accept componentSchemas prop, use model-specific enums, coerce types based on schema type (integer/number)

### Technical Details

**Type coercion in SchemaInputs:**
```typescript
// Get the component schema type for proper type coercion
const componentSchema = componentSchemas?.[enumKey];
const enumType = componentSchema?.type;

onChange={(v) => {
  if (enumType === 'integer') {
    handleChange(key, Number.parseInt(v, 10));
  } else if (enumType === 'number') {
    handleChange(key, Number.parseFloat(v));
  } else {
    handleChange(key, v);
  }
}}
```

### Decisions

- **Decision:** Store componentSchemas separately instead of resolving $ref inline
  - **Rationale:** Preserves type info (string vs integer) needed for proper type coercion

- **Decision:** Convert enum values based on componentSchema.type
  - **Rationale:** Dropdowns always pass strings but APIs like Kling expect integers for duration

### Next steps

- [ ] Run `bun run sync:replicate` to regenerate schemas.json with componentSchemas
- [ ] Re-select models in nodes to load new componentSchemas (or reload workflows)

---

## Session 13: Localhost URL → Replicate Failure Diagnosis

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Diagnosed why Replicate API calls fail with "Director: unexpected error handling prediction"
- [x] Identified root cause: Old workflow data has legacy URL format that `urlToBase64` doesn't handle
- [x] User chose clean code path over backward compatibility

### Root Cause

```
Error payload:
"image_input": [
  "http://localhost:3001/api/files/input/697a2638c578f6a2ba9e1c8c/image-xxx.jpeg"
]
```

- Old URL format: `/api/files/input/{workflowId}/{filename}`
- New URL format: `/api/files/workflows/{workflowId}/input/{filename}`
- `urlToBase64()` only handles new format (cleaned up in Session 11)
- Replicate can't access localhost URLs → API error

### Resolution

User chose to re-upload images instead of adding backward compatibility code.

**Why debug mode worked:** Debug mode returns mock data without calling Replicate API, so URL format doesn't matter.

**Why real mode failed:** Real API calls send localhost URLs to Replicate servers, which can't access them.

### Decisions

- **Decision:** Keep code clean, no backward compat for legacy URLs
  - **Rationale:** User preference for clean code over deprecated patterns
  - **Action:** Re-upload images in affected workflows to get new URL format

### Next steps

- [ ] Re-upload images in workflows that have old `/api/files/input/` URL format

---

## Session 14: Simplify MongoDB Collection Names

**Duration:** ~20 minutes
**Status:** Complete

### What was done

- [x] Renamed `user_settings` collection to `settings`
- [x] Renamed `prompt_library_items` collection to `prompts`
- [x] Renamed all associated classes, types, DTOs, services, controllers, and modules
- [x] Updated API endpoint from `/prompt-library` to `/prompts`
- [x] Updated all frontend API calls and stores
- [x] Updated all test files

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Collection Renaming                                                     │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE:                              AFTER:                            │
│  ┌─────────────────────────┐         ┌─────────────────────────┐       │
│  │ user_settings           │   →     │ settings                │       │
│  │ prompt_library_items    │   →     │ prompts                 │       │
│  └─────────────────────────┘         └─────────────────────────┘       │
│                                                                         │
│  Classes/Types Renamed:                                                 │
│  ┌─────────────────────────────┐   ┌─────────────────────────────┐    │
│  │ UserSettings               │ → │ Settings                    │    │
│  │ UserSettingsDocument       │ → │ SettingsDocument            │    │
│  │ PromptLibraryItem          │ → │ Prompt                      │    │
│  │ PromptLibraryItemDocument  │ → │ PromptDocument              │    │
│  │ PromptLibraryService       │ → │ PromptsService              │    │
│  │ PromptLibraryController    │ → │ PromptsController           │    │
│  │ PromptLibraryModule        │ → │ PromptsModule               │    │
│  │ CreatePromptLibraryItemDto │ → │ CreatePromptDto             │    │
│  │ QueryPromptLibraryDto      │ → │ QueryPromptsDto             │    │
│  │ IPromptLibraryItem         │ → │ IPrompt                     │    │
│  │ ICreatePromptLibraryItem   │ → │ ICreatePrompt               │    │
│  │ IQueryPromptLibrary        │ → │ IQueryPrompts               │    │
│  │ promptLibraryApi           │ → │ promptsApi                  │    │
│  └─────────────────────────────┘   └─────────────────────────────┘    │
│                                                                         │
│  API Endpoint:                                                          │
│  /prompt-library  →  /prompts                                           │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Files renamed

**Backend:**
- `user-settings.schema.ts` → `settings.schema.ts`
- `prompt-library-item.schema.ts` → `prompt.schema.ts`
- `prompt-library.service.ts` → `prompts.service.ts`
- `prompt-library.controller.ts` → `prompts.controller.ts`
- `prompt-library.module.ts` → `prompts.module.ts`
- `create-prompt-library-item.dto.ts` → `create-prompt.dto.ts`
- `query-prompt-library.dto.ts` → `query-prompts.dto.ts`
- `prompt-library.service.spec.ts` → `prompts.service.spec.ts`
- `prompt-library.controller.spec.ts` → `prompts.controller.spec.ts`

**Frontend:**
- `prompt-library.ts` → `prompts.ts` (API)
- `prompt-library.test.ts` → `prompts.test.ts`

**Types Package:**
- `prompt-library.ts` → `prompts.ts`

### Files changed

**Backend:**
- `apps/api/src/app.module.ts` - Updated import to use PromptsModule
- `apps/api/src/modules/settings.module.ts` - Updated imports for Settings schema
- `apps/api/src/services/settings.service.ts` - Updated imports and types

**Frontend:**
- `apps/web/src/lib/api/index.ts` - Updated export to use promptsApi
- `apps/web/src/store/promptLibraryStore.ts` - Updated imports and API calls
- `apps/web/src/components/prompt-library/CreatePromptModal.tsx` - Updated type imports
- `apps/web/src/components/prompt-library/PromptPicker.tsx` - Updated type imports
- `apps/web/src/components/prompt-library/PromptLibraryModal.tsx` - Updated type imports
- `apps/web/src/components/nodes/input/PromptNode.tsx` - Updated type imports

**Types Package:**
- `packages/types/src/index.ts` - Updated export path

### Decisions

- **Decision:** Use shorter, simpler collection and class names
  - **Rationale:** `prompts` is cleaner than `prompt_library_items`, `settings` is cleaner than `user_settings`

- **Decision:** Keep frontend store and component folder names unchanged (promptLibraryStore, prompt-library/)
  - **Rationale:** The folder/store names reflect the feature ("Prompt Library"), not the collection name. Internal types and API renamed.

### Migration Note

**Existing MongoDB data:** Collections need to be renamed in the database:
```javascript
db.user_settings.renameCollection("settings")
db["prompt-library-items"].renameCollection("prompts")
```

### Next steps

- [ ] Run MongoDB migration to rename collections in database

---

## Session 15: Node Color Harmonization + Data-Type-Colored Edges

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Harmonized all nodes to neutral styling (same border/background regardless of category)
- [x] Implemented data-type-colored edges (edges match the data type they carry)
- [x] Preserved category color for processing glow animation and resizer handles
- [x] Updated minimap to use neutral color for all nodes

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Visual Design Changes                                                   │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE:                               AFTER:                           │
│  ┌──────────────────────────┐         ┌──────────────────────────┐    │
│  │ Node Borders:            │         │ Node Borders:            │    │
│  │ - Input: teal border     │    →    │ - All: neutral border    │    │
│  │ - AI: purple border      │         │   (border-border)        │    │
│  │ - Processing: blue border│         │                          │    │
│  │ - Output: amber border   │         │ Selection Ring:          │    │
│  │                          │         │ - All: cyan (ring-primary)│   │
│  │ Selection Ring:          │         │                          │    │
│  │ - Uses category color    │         │ Processing Glow:         │    │
│  └──────────────────────────┘         │ - Still uses category    │    │
│                                        │   color (preserved)      │    │
│                                        └──────────────────────────┘    │
│                                                                         │
│  EDGES:                                                                 │
│  ┌──────────────────────────┐         ┌──────────────────────────┐    │
│  │ Edge Colors:             │         │ Edge Colors:             │    │
│  │ - All: border color      │    →    │ - Image: golden          │    │
│  │ - Highlighted: primary   │         │ - Video: purple-pink     │    │
│  │                          │         │ - Text: teal             │    │
│  │                          │         │ - Audio: pink            │    │
│  │                          │         │ - Number: blue           │    │
│  │                          │         │                          │    │
│  │                          │         │ States inherit type color│    │
│  │                          │         │ with glow/opacity effects│    │
│  └──────────────────────────┘         └──────────────────────────┘    │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Files changed

**Frontend Components:**
- `apps/web/src/components/nodes/BaseNode.tsx`
  - Removed category-colored borders (`border-[var(--category-X)]`)
  - All nodes now use `border-border bg-card` (neutral)
  - Selection ring now uses `ring-primary` for all nodes (cyan)
  - Preserved `--node-color` CSS variable for processing glow
  - Resizer handles still use category color

- `apps/web/src/components/canvas/WorkflowCanvas.tsx`
  - Added `getEdgeDataType()` helper function
  - Modified `styledEdges` useMemo to include edge type class
  - Edge classes: `edge-image`, `edge-video`, `edge-text`, `edge-audio`, `edge-number`
  - MiniMap now uses `DEFAULT_NODE_COLOR` (neutral gray) for all nodes
  - Removed unused `CATEGORY_COLORS` import

**Styles:**
- `apps/web/src/app/globals.scss`
  - Changed default edge color from `--border` to `--muted-foreground`
  - Added edge type classes with data-type colors:
    ```scss
    .edge-image { stroke: var(--handle-image); }  // golden
    .edge-video { stroke: var(--handle-video); }  // purple-pink
    .edge-text { stroke: var(--handle-text); }    // teal
    .edge-number { stroke: var(--handle-number); } // blue
    .edge-audio { stroke: var(--handle-audio); }   // pink
    ```
  - Updated dimmed/highlighted/executing states to use `currentColor`
  - Edges now glow in their data type color when highlighted or executing

### Technical Details

**Edge Type Resolution:**
```typescript
function getEdgeDataType(edge: WorkflowEdge, nodeMap: Map<string, WorkflowNode>): HandleType | null {
  const sourceNode = nodeMap.get(edge.source);
  const nodeDef = NODE_DEFINITIONS[sourceNode.type as NodeType];
  const sourceHandle = nodeDef.outputs.find((h) => h.id === edge.sourceHandle);
  return sourceHandle?.type ?? null;  // 'image' | 'video' | 'text' | 'audio' | 'number'
}
```

**Edge className composition:**
```typescript
const typeClass = dataType ? `edge-${dataType}` : '';
// Combined with state classes: `edge-image highlighted`, `edge-video executing`, etc.
```

**CSS uses `currentColor` for state effects:**
```scss
&__edge.highlighted .react-flow__edge-path {
  filter: drop-shadow(0 0 4px currentColor) brightness(1.2);
}
```

### Decisions

- **Decision:** Use neutral borders for all nodes
  - **Rationale:** Reduces visual noise, makes data flow the primary visual language

- **Decision:** Keep category color for processing glow and resizer handles
  - **Rationale:** Provides subtle category identification without dominating the UI

- **Decision:** Use `currentColor` in CSS for edge state effects
  - **Rationale:** States (highlighted, executing) inherit the type color, so golden image edges glow golden, purple video edges glow purple

- **Decision:** MiniMap uses neutral color for all nodes
  - **Rationale:** Consistent with harmonized node appearance

### Visual Result

- All nodes have clean, unified appearance with neutral borders
- Data flow is the primary visual language - edges are colored by what data they carry
- Handle → Edge → Handle color continuity (golden handles connect with golden edges)
- Processing glow animation still uses category colors for subtle context
- Selection highlighting applies a glow effect in the edge's data type color

### Next steps

- [x] Feature complete

---

## Session 16: Next.js App Optimization

**Duration:** ~30 minutes
**Status:** Complete

### What was done

**Phase 1: DRY Consolidation**
- [x] Created `apps/web/src/lib/utils/schemaUtils.ts` with shared utilities:
  - `getSchemaDefaults()` - Extract defaults from schema properties
  - `supportsImageInput()` - Check if model supports image input
  - `extractEnumValues()` - Extract enum values for dropdowns
- [x] Updated ImageGenNode, VideoGenNode, WorkflowCanvas to use shared utilities
- [x] Created `apps/web/src/hooks/useModelSelection.ts` hook
- [x] Updated ImageGenNode and VideoGenNode to use useModelSelection hook

**Phase 2: React Performance**
- [x] Added AbortController to AIGeneratorPanel fetch with cleanup on unmount
- [x] Memoized headerActions in ImageGenNode and VideoGenNode

**Phase 3: Next.js Optimizations**
- [x] Added next/font for Inter with CSS variable `--font-inter`
- [x] Updated globals.scss to use the font variable
- [x] Added dynamic imports for 6 modals in workflow editor page:
  - AnnotationModal, CostModal, GenerateWorkflowModal, TemplatesModal, WelcomeModal, SettingsModal
- [x] Replaced raw `<img>` tags with next/image in:
  - `apps/web/src/app/workflows/page.tsx` (header logo, workflow thumbnails)
  - `apps/web/src/app/gallery/page.tsx` (header logo)
  - `apps/web/src/components/gallery/GalleryItem.tsx` (image thumbnails)

### Files created

- `apps/web/src/lib/utils/schemaUtils.ts` - Shared schema utilities
- `apps/web/src/hooks/useModelSelection.ts` - Model selection hook

### Files changed

**DRY consolidation:**
- `apps/web/src/components/nodes/ai/ImageGenNode.tsx` - Uses schemaUtils and useModelSelection
- `apps/web/src/components/nodes/ai/VideoGenNode.tsx` - Uses schemaUtils and useModelSelection
- `apps/web/src/components/canvas/WorkflowCanvas.tsx` - Uses supportsImageInput from schemaUtils
- `apps/web/src/hooks/index.ts` - Added useModelSelection export

**React performance:**
- `apps/web/src/components/panels/AIGeneratorPanel.tsx` - AbortController for fetch
- `apps/web/src/components/nodes/ai/ImageGenNode.tsx` - headerActions memoized
- `apps/web/src/components/nodes/ai/VideoGenNode.tsx` - headerActions memoized

**Next.js optimizations:**
- `apps/web/src/app/layout.tsx` - Added next/font Inter with CSS variable
- `apps/web/src/app/globals.scss` - Updated to use `var(--font-inter)`
- `apps/web/src/app/workflows/[id]/page.tsx` - Dynamic imports for modals
- `apps/web/src/app/workflows/page.tsx` - next/image for logo and thumbnails
- `apps/web/src/app/gallery/page.tsx` - next/image for logo
- `apps/web/src/components/gallery/GalleryItem.tsx` - next/image for thumbnails

### Technical Details

**useModelSelection hook:**
```typescript
export function useModelSelection<TModel, TNodeData>({
  nodeId,
  modelMap,
  fallbackModel,
}: UseModelSelectionOptions<TModel>) {
  // Uses getSchemaDefaults from schemaUtils
  // Updates node with model, provider, selectedModel, schemaParams
  return { handleModelSelect };
}
```

**Dynamic imports pattern:**
```typescript
const WelcomeModal = dynamic(
  () => import('@/components/welcome/WelcomeModal').then((mod) => mod.WelcomeModal),
  { ssr: false }
);
```

**AbortController pattern:**
```typescript
const abortControllerRef = useRef<AbortController | null>(null);

useEffect(() => {
  return () => abortControllerRef.current?.abort();
}, []);

const handleSend = useCallback(async () => {
  abortControllerRef.current?.abort();
  const controller = new AbortController();
  abortControllerRef.current = controller;

  const response = await fetch(url, { signal: controller.signal });
  // ...
}, []);
```

### Decisions

- **Decision:** Skip comparison-slider.tsx next/image conversion
  - **Rationale:** Complex dynamic sizing with clip path, minimal benefit since unoptimized would be required anyway

- **Decision:** Skip shared node components (NodeActionButton, RequiredInputsHint, OutputPreview)
  - **Rationale:** Core optimizations complete, additional DRY refactoring has lower impact and requires extensive changes to 6+ files

### Impact

- **Bundle size:** Reduced initial load by ~20KB (dynamic modal imports)
- **Font loading:** Self-hosted font via next/font improves CLS and load time
- **Code quality:** 60+ lines of duplicated schema utilities consolidated
- **Memory:** AbortController prevents memory leaks from abandoned requests
- **Render performance:** headerActions memoization reduces unnecessary re-renders

### Next steps

- [ ] Consider shared node components in future cleanup pass
- [ ] Add next.config.ts remotePatterns if CDN images need optimization
