# Session Log: 2026-01-21

## Session 1: Add Pagination to /workflows Endpoint

**Time:** 2026-01-21
**Status:** Completed

### System Flow

```
GET /workflows?limit=X&offset=Y
         │
         ▼
┌─────────────────────────┐
│  WorkflowsController    │
│  @Query() decorator     │
│  validates QueryWorkflowDto
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│  WorkflowsService       │
│  .skip(offset)          │
│  .limit(limit)          │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│  MongoDB                │
│  workflows collection   │
└─────────────────────────┘
```

### Affected Components

- **Backend:** NestJS API (core)
- **Data:** MongoDB workflows collection

### What Was Done

- [x] Created `QueryWorkflowDto` with limit (default 20, max 100) and offset (default 0)
- [x] Updated `WorkflowsService.findAll()` to accept query params with `.skip()` and `.limit()`
- [x] Updated `WorkflowsController.findAll()` with `@Query()` decorator

### Key Decisions

| Decision | Rationale |
|----------|-----------|
| Offset-based pagination | Matches existing core codebase pattern (prompt-library module) |
| Default limit: 20 | Balance between usability and performance |
| Max limit: 100 | Prevent excessive queries |
| Sort by updatedAt DESC | Show most recently modified workflows first |

### Files Changed

| File | Action | Description |
|------|--------|-------------|
| `apps/api/src/dto/query-workflow.dto.ts` | Created | New DTO with limit/offset validation |
| `apps/api/src/services/workflows.service.ts` | Modified | Added query params to findAll() |
| `apps/api/src/controllers/workflows.controller.ts` | Modified | Added @Query() decorator |

### Patterns Established

- Follow `query-prompt-library.dto.ts` pattern for pagination DTOs
- Use class-transformer `@Transform` for query string number parsing
- Use class-validator decorators for validation constraints

### Mistakes and Fixes

None - implementation went smoothly following the existing pattern.

### Next Steps

- Consider adding total count to response for frontend pagination UI
- Consider adding search/filter params to QueryWorkflowDto if needed

---

## Session 2: Add Workflow Preview to Template Explorer

**Time:** 2026-01-21
**Status:** Completed

### System Flow

```
Template Explorer Card (TemplatesModal.tsx)
├── Has thumbnail? → Show <img> with thumbnail URL
└── No thumbnail? → Show <WorkflowPreview>
                    ├── Auto-layout nodes by depth (topological order)
                    ├── Color-coded rectangles by node category
                    ├── Edge connections between nodes
                    └── Non-interactive mini ReactFlow component
```

### Affected Components

- **Frontend:** Next.js web app (core)
- **UI:** Template Explorer modal

### What Was Done

- [x] Replaced generic `Layers` icon with `WorkflowPreview` component in template cards
- [x] Removed unused `Layers` import from lucide-react
- [x] Added `WorkflowPreview` component import

### Key Decisions

| Decision | Rationale |
|----------|-----------|
| Reuse existing `WorkflowPreview` | Already works well on dashboard, minimal code change |
| Keep thumbnail fallback logic | Templates with custom thumbnails still use those |

### Files Changed

| File | Action | Description |
|------|--------|-------------|
| `apps/web/src/components/templates/TemplatesModal.tsx` | Modified | Replaced Layers icon with WorkflowPreview component |

### Patterns Established

- Reuse `WorkflowPreview` component wherever workflow visualization is needed

### Mistakes and Fixes

None

### Next Steps

- [ ] Test the preview renders correctly for all templates
- [ ] Consider generating thumbnails for templates that run successfully

---

## Session 3: Dev Environment Setup + Schema/Module Refactor

**Time:** 2026-01-21
**Status:** Completed

### Summary

Fixed dev environment (.env, ngrok), refactored Mongoose schema indexes to follow cloud pattern, added status enums, cleaned up OSS workflows page.

### System Flow

```
dev-tunnel.ts loads .env → starts ngrok → sets WEBHOOK_BASE_URL → spawns API/web
                                ↓
Schemas define @Prop({ index/unique }) → Modules add compound indexes via forFeatureAsync
```

### What Was Done

- [x] Created `apps/api/.env.example` with all required env vars
- [x] Updated `scripts/dev-tunnel.ts` to load `.env` from `apps/api/`
- [x] Fixed ngrok auth by passing token directly (not `authtoken_from_env`)
- [x] Fixed WEBHOOK_BASE_URL inheritance by setting `process.env` before spawning API
- [x] Added `turbo` to devDependencies, added `packageManager` field
- [x] Added `turbo:api` script to root package.json
- [x] Cleaned up template seeding logs (only log new templates, debug for updates)
- [x] Fixed Mongoose duplicate index warning on `predictionId`
- [x] Refactored all 6 schemas to remove `.index()` calls
- [x] Converted 5 modules to `forFeatureAsync` with compound indexes
- [x] Single-field indexes use `@Prop({ index: true })` in schemas
- [x] Compound/text indexes defined in modules
- [x] Added status enums: `EXECUTION_STATUS`, `PREDICTION_STATUS`, `NODE_RESULT_STATUS`
- [x] Updated `execution.schema.ts` and `job.schema.ts` to use enums
- [x] Removed n8n "Overview" section from OSS workflows page (SaaS-only feature)

### Key Decisions

| Decision | Rationale |
|----------|-----------|
| Env file in `apps/api/` | Matches where API runs, not root |
| Single-field indexes in `@Prop` | Cleaner, follows Mongoose best practices |
| Compound indexes in module `useFactory` | Matches cloud pattern, supports plugins |
| Status enums in `queue.constants.ts` | Centralized, type-safe, avoids typos |
| OSS without Overview stats | SaaS-only feature, OSS keeps simple |

### Files Changed

**Created:**
- `apps/api/.env.example`

**Modified:**
- `scripts/dev-tunnel.ts` - load .env, pass authtoken directly, set process.env.WEBHOOK_BASE_URL
- `package.json` - added turbo, packageManager field, turbo:api script
- `apps/api/src/services/templates.service.ts` - cleaner seeding logs
- `apps/api/src/queue/queue.constants.ts` - added EXECUTION_STATUS, PREDICTION_STATUS, NODE_RESULT_STATUS
- `apps/api/src/schemas/job.schema.ts` - use PREDICTION_STATUS, removed .index()
- `apps/api/src/schemas/execution.schema.ts` - use EXECUTION_STATUS/NODE_RESULT_STATUS, removed .index()
- `apps/api/src/schemas/workflow.schema.ts` - removed .index(), added @Prop index
- `apps/api/src/schemas/queue-job.schema.ts` - removed .index() and redundant @Prop index
- `apps/api/src/schemas/template.schema.ts` - removed .index(), added @Prop index
- `apps/api/src/schemas/prompt-library-item.schema.ts` - removed .index(), added @Prop index
- `apps/api/src/modules/executions.module.ts` - forFeatureAsync with compound indexes
- `apps/api/src/modules/workflows.module.ts` - forFeatureAsync with compound indexes
- `apps/api/src/modules/queue.module.ts` - forFeatureAsync with compound indexes
- `apps/api/src/modules/templates.module.ts` - forFeatureAsync with compound indexes
- `apps/api/src/modules/prompt-library.module.ts` - forFeatureAsync with compound indexes
- `apps/web/src/app/workflows/page.tsx` - removed Overview/stats section
- `README.md` - updated .env paths to apps/api/

### Patterns Established

- **Mongoose indexes**: `@Prop({ unique: true })` for unique, `@Prop({ index: true })` for single-field, `schema.index()` in module useFactory for compound
- **Status enums**: Use `Object.values(ENUM)` for Mongoose enum, `ENUM.VALUE` for defaults
- **Dev tunnel**: Load .env manually, set process.env before spawn for child inheritance

---

## Session 4: Toolbar UI Adjustments

**Time:** 2026-01-21
**Status:** Completed

### Summary

Reduced logo size in toolbar, moved Marketplace/Discord/Twitter links to top right corner for better UX.

### System Flow

```
Toolbar.tsx Layout (before)
├── Logo (32px) | Title | [File Ops + Marketplace] | Settings | Discord | Cost | Save | Spacer | [Run Controls] | New

Toolbar.tsx Layout (after)
├── Logo (24px) | Title | [File Ops] | Settings | Cost | Save | Spacer | [Run Controls] | New | [Marketplace, Discord, Twitter]
```

### Affected Components

- **Frontend:** Next.js web app (core)
- **UI:** Toolbar component

### What Was Done

- [x] Reduced logo size from 32px to 24px (`h-8 w-8` → `h-6 w-6`)
- [x] Removed Marketplace from file operations section
- [x] Removed Discord from after Settings
- [x] Added XIcon (Twitter/X) SVG component
- [x] Added Marketplace, Discord, Twitter icons to top right (after "New" button)

### Key Decisions

| Decision | Rationale |
|----------|-----------|
| Logo 24px | User feedback - 32px felt too large for toolbar height |
| Social links top right | Standard placement for external links, matches cloud pattern |
| Group social links together | Visual consistency, easy to find |

### Files Changed

| File | Action | Description |
|------|--------|-------------|
| `apps/web/src/components/Toolbar.tsx` | Modified | Logo size, moved social links to right, added XIcon |

### Patterns Established

- Social/external links go in top right corner of toolbar
- Custom SVG icon components for brand icons (Discord, X)

### Mistakes and Fixes

None

### Next Steps

- [ ] Verify social links work correctly
- [ ] Consider adding more social links if needed (GitHub, etc.)

---

## Session 5: Workflow Switcher Dropdown

**Time:** 2026-01-21
**Status:** Completed

### Summary

Added a workflow switcher dropdown to the toolbar that allows users to quickly switch between workflows without leaving the editor. The workflow name remains editable, and switching workflows automatically saves the current workflow if dirty.

### System Flow

```
Toolbar Workflow Title (before)
├── Click name → Edit inline
└── No workflow switching capability

Toolbar Workflow Title (after)
├── Click name text → Edit inline (preserved)
├── Click chevron → Open dropdown
│   ├── Shows list of other workflows (fetched via API)
│   ├── Loading state while fetching
│   └── "New Workflow" option at bottom
└── Select workflow → Save current if dirty → Navigate to /workflows/:id
```

### Affected Components

- **Frontend:** Next.js web app (core)
- **UI:** Toolbar component, new WorkflowSwitcher component

### What Was Done

- [x] Created `WorkflowSwitcher` component with dropdown functionality
- [x] Dropdown fetches workflows list via `listWorkflows()` from store
- [x] Click on workflow name text to edit inline (existing behavior preserved)
- [x] Click chevron to open dropdown with other workflows
- [x] Auto-save current workflow if dirty before navigating
- [x] "New Workflow" footer option in dropdown
- [x] Replaced inline editing logic in Toolbar with WorkflowSwitcher component
- [x] Uses portal for dropdown positioning (follows PromptPicker pattern)

### Key Decisions

| Decision | Rationale |
|----------|-----------|
| Separate clickable areas | Name text for editing, chevron for dropdown - intuitive UX |
| Save before navigate | Prevents data loss when switching workflows |
| Follow PromptPicker pattern | Consistent dropdown implementation across codebase |
| Portal for dropdown | Ensures dropdown renders above other elements |
| Filter current workflow | Don't show current workflow in the list |

### Files Changed

| File | Action | Description |
|------|--------|-------------|
| `apps/web/src/components/workflow/WorkflowSwitcher.tsx` | Created | New component with dropdown and inline edit |
| `apps/web/src/components/Toolbar.tsx` | Modified | Import WorkflowSwitcher, replace title section, remove unused state |

### Patterns Established

- Dropdown components use `createPortal` to document.body
- Position calculated from trigger element's bounding rect
- Click outside detection via `mousedown` event listener
- Combine inline editing with dropdown selection in same component

### Mistakes and Fixes

None

### Next Steps

- [ ] Test workflow switching with unsaved changes
- [ ] Consider adding workflow search/filter in dropdown for users with many workflows
- [ ] Consider showing workflow count or last modified date in dropdown items

---

## Session 6: Sequential Workflow Execution (Rate Limit Fix)

**Time:** 2026-01-21
**Status:** Completed

### Summary

Implemented sequential workflow execution to prevent Replicate API rate limiting (429 errors). Instead of enqueueing all nodes at once (which caused parallel API calls), the system now processes one node at a time, waiting for webhook completion before enqueueing the next.

### System Flow

```
Workflow Execution (BEFORE - parallel)
──────────────────────────────────────
Orchestrator enqueues ALL nodes
         ↓
BullMQ processes 5 images / 2 videos concurrently
         ↓
Multiple Replicate API calls at once
         ↓
429 Rate Limit Error ❌

Workflow Execution (AFTER - sequential)
───────────────────────────────────────
Orchestrator saves ALL nodes to execution.pendingNodes
         ↓
Enqueues ONLY first ready node (no unmet dependencies)
         ↓
Processor creates prediction → polls for completion
         ↓
Webhook fires → updateNodeResult → continueExecution()
         ↓
continueExecution checks pendingNodes → enqueues next ready node
         ↓
Repeat until pendingNodes empty → execution completed ✅
```

### Affected Components

- **Backend:** NestJS API (core)
- **Queue:** BullMQ processors
- **Database:** Execution schema (new pendingNodes field)

### What Was Done

**Core Sequential Execution:**
- [x] Set queue concurrency to 1 for all Replicate queues (was 5/2/10/3)
- [x] Added `pendingNodes` field to Execution schema
- [x] Modified workflow orchestrator to only enqueue first ready node
- [x] Added `continueExecution` method to QueueManagerService
- [x] Webhook handler calls `continueExecution` after node completes

**Retry & Failure Handling:**
- [x] Added `findExistingJob` to prevent duplicate predictions on BullMQ retry
- [x] Enhanced `checkExecutionCompletion` to handle blocked dependents
- [x] Processors check for existing prediction before creating new one
- [x] Processors trigger continuation on final failure (all retries exhausted)
- [x] Blocked nodes marked as "Skipped: dependency failed"

### Key Decisions

| Decision | Rationale |
|----------|-----------|
| Concurrency = 1 per queue | Ensures only one Replicate API call at a time |
| Webhook-driven continuation | Reliable, event-based progression vs polling-based |
| Store pendingNodes in execution | Survives process restarts, enables recovery |
| Check existing prediction on retry | Prevents duplicate API calls and wasted credits |
| Mark blocked nodes as error | Clean execution completion when dependency fails |

### Files Changed

| File | Action | Description |
|------|--------|-------------|
| `apps/api/src/queue/queue.constants.ts` | Modified | Set all Replicate queue concurrency to 1 |
| `apps/api/src/schemas/execution.schema.ts` | Modified | Added `pendingNodes` field |
| `apps/api/src/services/executions.service.ts` | Modified | Added `setPendingNodes`, `getReadyNodes`, `removeFromPendingNodes`, `checkExecutionCompletion`, `findExistingJob` |
| `apps/api/src/services/queue-manager.service.ts` | Modified | Added `continueExecution` method |
| `apps/api/src/processors/workflow.processor.ts` | Modified | Only enqueue first ready node, save rest to pendingNodes |
| `apps/api/src/services/replicate.service.ts` | Modified | Call `continueExecution` from webhook handler |
| `apps/api/src/modules/replicate.module.ts` | Modified | Added QueueModule import for DI |
| `apps/api/src/processors/image.processor.ts` | Modified | Retry handling, continuation on failure |
| `apps/api/src/processors/video.processor.ts` | Modified | Retry handling, continuation on failure |
| `apps/api/src/processors/processing.processor.ts` | Modified | Retry handling for Replicate ops, continuation on failure |
| `apps/api/src/processors/llm.processor.ts` | Modified | Continuation on failure |

### Patterns Established

- **Sequential execution**: pendingNodes array + webhook-driven continuation
- **Retry safety**: Check `findExistingJob` before creating prediction
- **Failure propagation**: Blocked dependents marked as skipped, execution fails gracefully
- **Centralized continuation**: `QueueManagerService.continueExecution()` called from webhook and processor failure handlers

### Mistakes and Fixes

None - implementation followed existing patterns in codebase.

### Next Steps

- [ ] Monitor for any edge cases with complex workflow graphs
- [ ] Consider adding parallel execution mode as option for users with higher rate limits
- [ ] Add execution progress percentage based on completed/total nodes

---

## Session 7: CostModal Implementation + Performance Optimization

**Time:** 2026-01-21
**Status:** Completed

### Summary

Implemented a CostModal component with two tabs: Cost Breakdown (per-node cost estimates) and Execution History (historical costs from API). Then optimized the code to fix race conditions and CPU spikes.

### System Flow

```
CostModal (activeModal === 'cost')
├── Tab: Cost Breakdown
│   ├── useWorkflowStore(nodes) → extractCostRelevantData() → calculateWorkflowCostWithBreakdown()
│   ├── Groups by node type (imageGen, videoGen, lipSync, llm)
│   ├── Expandable sections with per-node details
│   └── Pricing reference section
│
└── Tab: Execution History
    ├── GET /workflows/:id/executions → list recent executions
    ├── Expandable rows → GET /executions/:id/costs (lazy loaded, cached)
    ├── Shows estimated vs actual cost with variance %
    └── Color-coded variance (green < -10%, red > +10%)
```

### Affected Components

- **Frontend:** Next.js web app (core)
- **UI:** New CostModal, CostBreakdownTab, ExecutionHistoryTab components
- **Lib:** Enhanced replicate/client.ts with breakdown support

### What Was Done

- [x] Created `CostModal.tsx` with tab navigation (Cost Breakdown / Execution History)
- [x] Created `CostBreakdownTab.tsx` with grouped cost display and pricing reference
- [x] Created `ExecutionHistoryTab.tsx` with execution history and lazy-loaded job costs
- [x] Created `cost/index.ts` re-export
- [x] Added `calculateWorkflowCostWithBreakdown()` function with `CostBreakdownItem` interface
- [x] Added CostModal to workflow editor page
- [x] **OPTIMIZATION:** Fixed race condition in `loadCostDetails` - changed `costCache` from useState to useRef
- [x] **OPTIMIZATION:** Added AbortController to all async operations with proper cleanup
- [x] **OPTIMIZATION:** Added `extractCostRelevantData()` to prevent recalc on node drag
- [x] **OPTIMIZATION:** Added MAX_CACHE_SIZE (50) with LRU eviction
- [x] **OPTIMIZATION:** Used selector pattern for Zustand store subscriptions
- [x] **OPTIMIZATION:** Wrapped list items with `memo()` (ExecutionRow, NodeTypeGroupSection)

### Key Decisions

| Decision | Rationale |
|----------|-----------|
| Two-tab layout | Separates current estimates from historical data |
| Lazy-load job costs | Reduces initial API load, only fetch when expanded |
| useRef for cache | Prevents callback recreation → race conditions |
| extractCostRelevantData | Only recalculate when model/duration/etc changes, not position |
| AbortController everywhere | Cancel stale requests on unmount/re-request |

### Files Changed

| File | Action | Description |
|------|--------|-------------|
| `apps/web/src/components/cost/CostModal.tsx` | Created | Main modal with tab navigation, ESC key handling |
| `apps/web/src/components/cost/CostBreakdownTab.tsx` | Created | Per-node cost estimates with grouping and pricing reference |
| `apps/web/src/components/cost/ExecutionHistoryTab.tsx` | Created | Execution history with expandable job costs |
| `apps/web/src/components/cost/index.ts` | Created | Re-export |
| `apps/web/src/lib/replicate/client.ts` | Modified | Added calculateWorkflowCostWithBreakdown(), CostBreakdownItem, CostBreakdownResult |
| `apps/web/src/app/workflows/[id]/page.tsx` | Modified | Added CostModal import and component |

### Patterns Established

- **Race condition prevention:** Use `useRef` for caches that shouldn't trigger re-renders
- **Selective store subscription:** `useStore((state) => state.field)` instead of destructuring
- **AbortController pattern:** Every async useEffect/callback gets its own controller with cleanup
- **Stable dependency extraction:** Create string representation of only relevant data for useMemo deps
- **Memoized list items:** Always wrap list item components with `memo()`

### Mistakes and Fixes

| Mistake | Impact | Fix |
|---------|--------|-----|
| `costCache` in useState | Callback recreation on every cache update → CPU spike | Changed to useRef |
| No AbortController on detail loading | Stale responses updated state after unmount | Added AbortController with signal |
| Full nodes array in useMemo deps | Recalculated on every drag/position change | extractCostRelevantData() filters to cost-relevant props |
| Missing memo() on list items | Unnecessary re-renders of all rows | Wrapped with memo() |

### Next Steps

- [ ] Verify API endpoints exist: GET /workflows/:id/executions, GET /executions/:id/costs
- [ ] Test modal opens from toolbar cost indicator
- [ ] Verify estimated vs actual cost variance displays correctly

---
